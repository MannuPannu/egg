\input texinfo.tex    @c -*-texinfo-*-
@c %**start of header
@setfilename egg.info
@settitle EEG User Manual
@documentencoding utf-8
@paragraphindent none
@c %**end of header

@dircategory Emacs
@direntry
* Egg: (egg).        Emacs Got Git
@end direntry

@copying
Copyright @copyright{} 2009, 2010, 2011 Bogolisk <bogolisk@@gmail.com>.

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with no Front-Cover Texts, and with no Back-Cover
Texts.
@end quotation
@end copying

@node Top, Rant, (dir), (dir)
@top Egg User Manual

@sc{Egg} is an attempt to provide a seamless integration of @sc{Git}
within @sc{Emacs}.  @sc{Egg} is currently tested with @sc{Git} 1.7.12
and @sc{Emacs} 23. It may work with other versions of @sc{Emacs} and
@sc{Git} but the @sc{Egg}'s developer does not have time to investigate
and fix bugs that only appear in versions or platforms that he doesn't
use. Patches to fix bugs in other emacsen or volunteers to maintain
compatibility however are welcome.

@menu
* Rant::                        
* Acknowledgements::            
* Overview::                    
* File::                        
* Status::                      
* History::                     
* Reflogs::                     
* Commit Buffer::               
* Diffing::                     
* Tagging::                     
* Resetting::                   
* Stashing::                    
* Branching::                   
* The Branch Manager::          
* Wazzup::                      
* Merging::                     
* Rebasing::                    
* Rewriting::                   
* Pushing and Pulling::         
* Submodules::                  
* Bisecting::                   
* Using Egg Extensions::        
* Using Git Directly::          
* Customization::               
* Frequently Asked Questions::  

@detailmenu
 --- The Detailed Node Listing ---

Overview

* Buffers::                     
* Sections::                    
* Diff Sections::               

File

* Minor Mode::                  
* Blame::                       

Status

* Unstaged::                    
* Staged::                      
* Untracked::                   
* Status Buffer Commands::      

Egg Extensions

* Activating extensions::       
* Interfacing with Subversion::  
* Interfacing with Topgit::     
* Interfacing with StGit::      
* Developing Extensions::       

Frequently Asked Questions

* FAQ - Changes::               
* FAQ 1 - Troubleshooting::     
* FAQ 2 - Display issues::      

Troubleshooting

* FAQ 1-1::                     How do I get raw error messages from git?

Display issues

* FAQ 2-1::                     How do I fix international characters display?

@end detailmenu
@end menu

@node Rant, Acknowledgements, Top, Top
@unnumbered Rant

@sc{Egg} wasn't designed to replace the @sc{Git} excellent official
porcelain layer, especially when used with the @t{bash_completion}
package. In the @sc{Egg}'s developer's opinion: it's pointless to write
a @t{git-mode} in emacs to let user type @kbd{M-x git-reset} when he/she
can do exactly the same thing in @sc{Bash}. An emacs interface to
@sc{Git} should provide the conveniences that would make it easier to
accomplish the same task than the @sc{Git}'s porcelain. @sc{Egg}, thus,
was designed to perform the same goal as @sc{Git Aliases}. Make it more
convenient to accomplish common git operations.

One example:

The in @sc{Egg's} status buffer, when the user @emph{unstages} a file,
@sc{Egg} would invoke different git operations depend on the
origin/status of the file: it was an existing file, it was new file or
it was a file with merge conflicts which were just resolved in the
index.

Again, @sc{Egg} was design to help you accomplish many git common
operations in very convenient @sc{Emacs} way.

As with @sc{Git Aliases}, @sc{Egg} won't save you from learning
@sc{Git}. Instead it expects its user to be familiar with @sc{Git}. This
manual tries to document all @sc{Egg} functionalities and explain the
design of some of the commands.

@node Acknowledgements, Overview, Rant, Top
@unnumbered Acknowledgements

In the beginning, @sc{Egg} was a fork of @sc{Marius Vollmer}'s excellent
@sc{Magit}. While @sc{Egg} was later completely rewritten, it still
keeps the genius @emph{staging/unstaging} metaphor in the @emph{status
buffer}.

@sc{ByPlayer} gracefully picked up the maintainership when Bogolisk went
hiatus for several... years!!! He's the current maintainer of @sc{Egg}
and his repo is at: @file{https://github.com/byplayer/egg}

@node Overview, File, Acknowledgements, Top
@unnumbered Overview

Using @sc{Egg} is simple:
@itemize
@item
download @file{egg.el} and put in your @sc{Emacs}'s @code{loadpath}.
@item
add @code{(require 'egg)} in your @file{.emacs}
@item
very important: disable @sc{Vc}'s git backend.
Do @kbd{M-x customize-option RET vc-handled-backends}.
Then @key{DEL} the Git option.
@item
open a file in a git repo from within emacs. Et voila!
@end itemize

@menu
* Buffers::                     
* Sections::                    
* Diff Sections::               
@end menu

@node Buffers, Sections, Overview, Overview
@unnumberedsec Buffers
When the user visits files from a git repository with, @sc{Egg} creates
(on demand) several @emph{egg special buffers}. Some of them are:

(in the following list, @t{REPO} is name of the git repo and @t{GIT-DIR}
is the path of the git directory.)

@itemize
@item  @t{*REPO-status@@GIT-DIR*}
 the status buffer. it's intended to manipulate the index such as
 resolving merge.
@item @t{*REPO-log@@GIT-DIR*}
 the log buffer. This is probably the most feature-full egg special
 buffer. It's intended: to inspect and manipulate the repo history such
 as create/destroy refs; to push/fetch branches to/from remote repo;
 pickaxing; cherry-picking; reverting; merging; interactive-rebasing...

 It has too cousins: @t{*REPO-stash@@GIT-DIR*} and
 @t{*REPO-reflog@@GIT-DIR*}. These are used to view and manipulate the
 stashes and reflogs.

@item @t{*REPO-commit@@GIT-DIR*}
 the commit buffer. It's used to composed commit message. It's also has a
 cousin, @t{*REPO-tag@@GIT-DIR*}, which is used to compose the message
 for annotated tags.

@item @t{*REPO-diff@@GIT-DIR*}
 the diff buffer. It's used to compare files vs index or other
 revisions.
@end itemize

For example, if your standard repo was @file{/path/to/foo/} then the status
buffer would be: @t{*foo-status@/path/to/foo/.git*}.

@sc{Egg}'s special buffers have some common key bindings:
@itemize
@anchor{egg-buffer-mode-map}
@item @kbd{q} (@code{egg-quit-buffer})
 leaves and burries the buffer.
@item @kbd{g} (@code{egg-buffer-cmd-refresh})
 redisplay the contents of the buffer.
@item @kbd{n} (@code{egg-buffer-cmd-navigate-next})
moves cursor to the next interesting thing.
@item @kbd{p} (@code{egg-buffer-cmd-navigate-prev})
moves cursor to the previous interesting thing.
@end itemize


@node Sections, Diff Sections, Buffers, Overview
@unnumberedsec Sections

@sc{Egg} speciall buffers usually contains more than one
@emph{sections}.These sections can be hidden and shown individually.
When a section is hidden, only its first line is shown and all its
children are completely invisible. The following keys are bound to
section-specific commands when the cursor is on a section. Those keys
are bound in a local @t{keymap} thus will only invoke the @sc{Egg}'s
command when the cursor is in a section.

@anchor{egg-section-map}
@itemize
@item @kbd{h} or @key{mouse-2} (@code{egg-section-cmd-toggle-hide-show})
toggles the visibility of a section.
@item @kbd{H} (@code{egg-section-cmd-toggle-hide-show-children})
toggles the visibility of the @emph{subsections} of the section.
@item @kbd{n} (@code{egg-buffer-cmd-navigate-next})
moves point to the next section
@item @kbd{p} (@code{egg-buffer-cmd-navigate-prev})
moves point to the previous section
@end itemize

@node Diff Sections,  , Sections, Overview
@unnumberedsec Diff Sections
Many @sc{Egg}'s special buffers contain @emph{diff sections}. Each diff
section has a header with information about the file being compared and
revision information followed by a sequence of hunks. A diff section
inherits all local keybindings of a section
@xref{egg-section-map}. Plus, when the cursor is in the header part of
the diff section, the following keys are bound to @sc{Egg}'s commands:

@itemize
@anchor{egg-diff-section-map}
@item @kbd{RET} (@code{egg-diff-section-cmd-visit-file-other-window})
 visits the file (refered to by the diff header) in the other window.
@item @kbd{f} (@code{egg-diff-section-cmd-visit-file})
 visits the file (refered to by the diff header) in the current window.
@item @kbd{=} (@code{egg-diff-section-cmd-ediff})
 launches ediff to the compare file (refered to by the diff header).  the
 two operands commpared in ediff would be same as described in the diff
 header.
@end itemize

When the cursor is in a hunk, in addition to the keys bound for a
section @xref{egg-section-map}, the following keys are defined:

@itemize
@anchor{egg-hunk-section-map}
@item @kbd{RET} (@code{egg-hunk-section-cmd-visit-file-other-window})
 visits the file (refered to by the diff header) in the other window.
 The command also moves point to the location described in the hunk.
@item @kbd{f} (@code{egg-hunk-section-cmd-visit-file})
 visits the file (refered to by the diff header) in the current window.
 The command also moves point to the location described in the hunk.
@item @kbd{=} (@code{egg-diff-section-cmd-ediff})
 launches ediff to the compare file (refered to by the diff header).  the
 two operands commpared in ediff would be same as described in the diff
 header.
@end itemize

@node File, Status, Overview, Top
@unnumbered File
When you're editing a file from a git repository, @sc{Egg} provides a
number of commands in the @code{egg-minor-mode} to perform
@sc{git}-related operations.  @sc{Egg} also provide a @sc{blame-mode} to
view the current file with annotations.

@menu
* Minor Mode::                  
* Blame::                       
@end menu

@node Minor Mode, Blame, File, File
@unnumberedsec Minor Mode
When visiting a file in a @sc{Git} repository, @sc{Egg} provides the following
commands. They are bound to the prefix @kbd{C-x v}. Most of them also behave
differently with prefixes (@kbd{C-u} and @kbd{C-u C-u})

@itemize
@item @kbd{a} (@code{egg-file-toggle-blame-mode})
 toggles the @emph{view annotations} or @emph{blame mode}. If the buffer
 was modified, the command will prompt the user to offer to save the
 current buffer first.  With @kbd{C-u} prefix, the command will save the
 current buffer without prompting. @xref{Blame, Annotations or Blame},
 for details on @emph{blame-mode}.
@item @kbd{b} (@code{egg-start-new-branch}) @anchor{egg-start-new-branch}
 starts a new branch (from the current HEAD.) With the @kbd{C-u} prefix, a branch
 will be created even if it would replace an existing branch.
@item @kbd{d} or @kbd{s} (@code{egg-status})
 shows (without selecting) the status buffer. With @kbd{C-u} prefix, the
 status buffer will be selected. @xref{Status}, for more details.
@item @kbd{c} or @kbd{w} (@code{egg-commit-log-edit})
 starts composing a message to commit. With @kbd{C-u} prefix, the
 composed message will be used for amending the latest commit and the
 existing message will be pre-inserted into the buffer for editing.
 With @kbd{C-u C-u} prefix, the index will be used to immediately (no
 editing) amend the latest commit, re-using its existing message.
 cf:egg-commit-log-edit
@item @kbd{e} (@code{egg-file-ediff}) @anchor{egg-file-ediff}
 prompts for another revision and compare the contents of the current
 file in the work-tree using @t{ediff}. With @kbd{C-u} prefix, prompt
 for @emph{two} different revisions and to compare their's contents of
 the file using @t{ediff}.
@item @kbd{g} (@code{egg-grep})
 runs @t{git-grep} in a @t{grep-mode} buffer. With @kbd{C-u} prefix, use
 the string at point to as the default search term. With @kbd{C-u C-u}
 prefix, prompt for a revision (instead of the current checked-out
 contents in the work-tree) to perform the search. cf:egg-grep
@item @kbd{i} (@code{egg-file-stage-current-file}) @anchor{egg-file-stage-current-file}
 adds the current file's contents into the index.
@item @kbd{l} (@code{egg-log})
 launchs the log buffer to view the current @t{HEAD}'s history. With
 @kbd{C-u} prefix, show the history of all branches. cf:egg-log
@item @kbd{L} (@code{egg-reflog})
 launch the reflog buffer to view @t{HEAD}'s reflog. With @kbd{C-u}
 prefix, prompt for a branch name then show its reflog. cf:egg-reflog
@item @kbd{h} (@code{egg-file-log})
 launch the filelog buffer to view current file's history in the current
 branch. With @kbd{C-u} prefix, show the current file's history in all
 branches. cf:egg-file-log
@item @kbd{o} (@code{egg-file-checkout-other-version}) @anchor{egg-file-checkout-other-version}
 checkout the current file's contents from a different revision. With @kbd{C-u}
 prefix, will not prompt for confirmation if the file has uncommitted changes.
@item @kbd{S} (@code{egg-statsh})
 launch the stash buffer to view repo's stashes. cf:egg-stash
@item @kbd{u} (@code{egg-file-cancel-modifications}) @anchor{egg-file-cancel-modifications}
 throw away all unstaged modifications of the current
 file. I.e. checkout the current file contents from the index. With
 @kbd{C-u} prefix, will not prompt for confirmation if the file has
 unstaged changes.
@item @kbd{v} (@code{egg-next-action})
 guess and perform the next @emph{logical} step of the @emph{workflow}.
 With @kbd{C-u} prefix, prompt for confirmation before starting the
 @emph{next} action. cf:egg-next-action
@item @kbd{/} (@code{egg-file-log-pickaxe})
 search the current file's history to the string under the cursor.
 cf:egg-file-log-pickaxe
@item @kbd{=} (@code{egg-file-diff}) @anchor{egg-file-diff}
 open the @emph{diff buffer} to compare the current file's contents in
 the work-tree vs the index. With @kbd{C-u} prefix, will prompt for a
 revision as base of the comparison instead of the index.
@item @kbd{~} (@code{egg-file-version-other-window}) @anchor{egg-file-version-other-window}
 show the staged (from the index) contents of the current buffer With
 @kbd{C-u} prefix, will prompt for a revision and show the file's
 contents from that revision.
@end itemize 

@node Blame,  , Minor Mode, File
@unnumberedsec Annotations or Blame
The command @code{egg-file-toggle-blame-mode} will bring the current
file in and out of @emph{annotation-mode} a.k.a @emph{blame-mode}.

In annotation mode, the buffer is read-only. Block of lines is preceded
by an annotation about the last commit that changed that part of the
file.  The annotatin is a display-only (its text doesn't really exist in
the buffer) line similar to this:

@code{453f3f13   Bogolisk                  ignore and README}

The leading hexadecimal number is the sha1 of the commit. The following
part is the name of the committor and the subject of the commit. The
following keys are bound to @sc{Egg} commands in blame-mode.

@itemize
@item @kbd{l} or @kbd{RET} (@code{egg-blame-locate-commit})
 locates the @emph{blamed} commit in the the repo's history
 (@code{egg-log}, cf:egg-log). The command will open the repo history
 and move the cursor to the @emph{blamed} commit. With @kbd{C-u} prefix,
 the history of all branches will be shown (instead of just the current
 branch.)
@item @kbd{q} (@code{egg-file-toggle-blame-mode})
 leaves annotations mode and back to normal editing mode.
@item @kbd{n} (@code{egg-buffer-cmd-navigate-next})
 jump to the next annotation.
@item @kbd{p} (@code{egg-buffer-cmd-navigate-prev})
 jump to the previous annotation.
@end itemize

@node Status, History, File, Top
@unnumbered Status
The command @code{egg-status} open the status buffer. The top of the
status buffer shows the current HEAD (whether it's @emph{symbolic} or
@emph{detached}).  It also shows the current sha1 of HEAD as well as the
git directory.

Below the top part is the @sc{Help} section, described the common key
bindings of in the status buffer. This is @sc{Help} section's visibility
can be toggled as described in @ref{Sections}.

Following the Help section are the @sc{Unstaged Changes}, @sc{Staged
Changes} and @sc{Untracked Files} sections. Each of them inherits the
local keybindings as described in @ref{Sections}.

@menu
* Unstaged::                    
* Staged::                      
* Untracked::                   
* Status Buffer Commands::      
@end menu

@node Unstaged, Staged, Status, Status
@unnumberedsec Unstaged Files
If there were differences between the index and the work-dir, the
@sc{Unstaged Files} section would contains a sequence of diff sections
(@xref{Diff Sections}.) In addition to the key bindings described in
@ref{egg-section-map,,Section Key Bindings} and
@ref{egg-diff-section-map,,Diff Section Key Bindings}, the following
key bindings are defined when the cursor is in a diff header in the
@sc{Unstaged Files} section:

@itemize
@anchor{egg-unstaged-diff-section-map}
@item @kbd{=} (@code{egg-unstaged-section-cmd-ediff})
 launches ediff to compare the file's contents in the work-dir vs the index.
@item @kbd{s} (@code{egg-diff-section-cmd-stage})
 adds the file's contents to the index.
@item @kbd{u} (@code{egg-diff-section-cmd-undo})
 throws away unstaged local modifications. The command basically
 checkouts the file's contents from the index.
@item @kbd{x} (@code{egg-diff-section-revert-to-head})
 throw away all unstaged and staged changes. The command basically
 checkouts the file's contents from HEAD.
@item @key{mouse-2}
 shows a menu for the bound commands on a unstaged diff section.
@end itemize

If there were unmerged conflicts in the work-dir, then the
@sc{Unstaged Files} section would instead contain a sequence of
combined diff sections describing the merge conflicts. In this case,
the local key bindings are exactly the same as described in
@ref{egg-unstaged-diff-section-map,,Unstaged Diff Section Key
Bindings}, with one difference. The key @kbd{=} would launch a 3-way
ediff section between @emph{ours}, @emph{theirs} and the work-dir's
contents of the file to resolve the conflicts.

@node Staged, Untracked, Unstaged, Status
@unnumberedsec Staged Files
If there were differences between the index and HEAD, the @sc{Unstaged
Files} section would contains a sequence of diff sections (@xref{Diff
Sections}.) In addition to the key bindings described in
@ref{egg-section-map,,Section Key Bindings} and
@ref{egg-diff-section-map,,Diff Section Key Bindings}, the following
key bindings are defined when the cursor is in a diff header in the
@sc{Staged Files} section:

@itemize
@anchor{egg-staged-diff-section-map}
@item @kbd{=} (@code{egg-staged-section-cmd-ediff3})
 launches 3-way ediff to compare the file's contents in the work-dir vs
 the index vs HEAD.
@item @kbd{s} (@code{egg-diff-section-cmd-unstage})
 remove the staged modifications of the current file in the index.
This command basically reset the slot of current file in the index. If
the file was a new file, the command will remove its slot in the index.
@item @kbd{x} (@code{egg-diff-section-revert-to-head})
 throw away all unstaged and staged changes. The command basically
 checkouts the file's contents from HEAD.
@item @key{mouse-2}
 shows a menu for the bound commands on a staged diff section.
@end itemize

If there were resolved merge conflicts in the index, the command
@code{egg-diff-section-cmd-unstage}, bound to the key @kbd{s}, will
restore the unresoved state of the file.

@node Untracked, Status Buffer Commands, Staged, Status
@unnumberedsec Untracked Files
This section of the status buffer lists the untracked files in the
work-dir. The user can visit them, add them to the index or ignore
them using the commands listed below.

@itemize
@item @key{RET} (@code{egg-find-file-at-point})
visits the file under the cursor.
@item @key{DEL} (@code{egg-ignore-pattern-from-string-at-point})
add a pattern to the @file{.gitignore} file based on the file name
under the cursor.
@item @kbd{s} or @kbd{i} (@code{egg-status-buffer-stage-untracked-file})
add the file under the cursor or, if the region was active, the files
in the region into the index. with @kbd{C-u} prefix, only add the
entries for the new file(s) in the index but do not add their
contents.
@end itemize

@node Status Buffer Commands,  , Untracked, Status
@unnumberedsec Status Buffer Commands

Other than the commands described in @ref{egg-buffer-mode-map} and the
commands bound locally to the above sections (Unstaged, Staged and
Untracked), the status buffer also bind the following commands:

@itemize
@anchor{egg-status-buffer-mode-map}
@item @kbd{c} (@code{egg-commit-log-edit})
starts composing a message to commit. With @kbd{C-u} prefix, the
composed message will be used for amending the latest commit and the
existing message will be pre-inserted into the buffer for editing.
With @kbd{C-u C-u} prefix, the index will be used to immediately (no
editing) amend the latest commit, re-using its existing message.
cf:egg-commit-log-edit
@item @kbd{o} (@code{egg-status-buffer-checkout-ref})
prompts for a ref name and check it out.
@item @kbd{l} (@code{egg-log})
launches the log buffer to view the current @t{HEAD}'s history. With
@kbd{C-u} prefix, show the history of all branches. cf:egg-log
@item @kbd{w} (@code{egg-status-buffer-stash-wip})
stash the index and the work-dir for later. The command will prompt
for a short description of the to-be-stashed work-in-progress. With
@kbd{C-u} prefix, the command will ask for confirmation whether
untracked files are to be included in the stash.
cf:egg-status-buffer-stash-wip
@item @kbd{W} (@code{egg-stash})
shows the stack of stashed work-in-progress entries. cf:egg-stash
@item @kbd{L} (@code{egg-reflog})
launches the reflog buffer to view @t{HEAD}'s reflog. With @kbd{C-u}
prefix, prompt for a branch name then show its reflog. cf:egg-reflog
@item @kbd{S} (@code{egg-stage-all-files})
add all tracked files's contents to the index
@item @kbd{U} (@code{egg-unstage-all-files})
remove all staged modifications from the index. This commands basically reset
the index back to HEAD.
@item @kbd{X} (@code{egg-status-buffer-undo-wdir})
throws away all unstaged modifications. With @kbd{C-u} prefix, the
commands throws away all uncommited modifications (staged and
unstaged.) This commands basically reset the index and the work-dir
back to HEAD.
@item @kbd{d} (@code{egg-diff-ref})
prompt for a revision and open the @emph{diff buffer} to compare the
work-tree's contents in the work-tree vs that revision. This commands
compares the whole work-tree while @ref{egg-file-diff} compares a single
file.
@end itemize

@node Log
@unnumbered Log

To show the repository history of your current head, type @kbd{l l}.  A
new buffer will be shown that displays the history in a terse form.
The first paragraph of each commit message is displayed, next to a
representation of the relationships between commits.

To show the repository history between two branches or between any two
points of the history, type @kbd{l r l}.  You will be prompted to enter
references for starting point and ending point of the history range; you
can use auto-completion to specify them.  A typical use case for ranged
history log display would be @kbd{l r l master RET new-feature RET} that
will display commits on the new-feature branch that are not in master;
these commits can then be inspected and cherry-picked, for example.

More thorough filtering can be done by supplying @kbd{l} with one or
more suffix arguments, as displayed in its popup.  @kbd{=g} ('Grep')
for example, limits the output to commits of which the log message
matches a specific string/regex.

Typing @kbd{l L} (or @kbd{l C-u L}) will show the log in a more verbose
form.

Egg will show only @code{magit-log-cutoff-length} entries. @kbd{e}
will show twice as many entries. @kbd{C-u e} will show all entries,
and given a numeric prefix argument, @kbd{e} will add this number of
entries.

You can move point to a commit and then cause various things to happen
with it.  (The following commands work in any list of commits, such as
the one shown in the @emph{Unpushed commits} section.)

Typing @kbd{RET} will pop up more information about the current commit
and move point into the new buffer.  @xref{Commit Buffer}.  Typing
@kbd{SPC} and @kbd{DEL} will also show the information, but will
scroll the new buffer up or down (respectively) when typed again.

Typing @kbd{a} will apply the current commit to your current branch.
This is useful when you are browsing the history of some other branch
and you want to `cherry-pick' some changes from it.  A typical
situation is applying selected bug fixes from the development version
of a program to a release branch.  The cherry-picked changes will not
be committed automatically; you need to do that explicitly.

Typing @kbd{A} will cherry-pick the current commit and will also
commit the changes automatically when there have not been any
conflicts.

Typing @kbd{v} will revert the current commit.  Thus, it will apply
the changes made by that commit in reverse.  This is obviously useful
to cleanly undo changes that turned out to be wrong.  As with @kbd{a},
you need to commit the changes explicitly.

Typing @kbd{C-w} will copy the sha1 of the current commit into the
kill ring.

Typing @kbd{=} will show the differences from the current commit to
the @dfn{marked} commit.

You can mark the current commit by typing @kbd{.}.  When the current
commit is already marked, typing @kbd{.} will unmark it.  To unmark
the marked commit no matter where point is, use @kbd{C-u .}.

Some commands, such as @kbd{=}, will use the current commit and the
marked commit as implicit arguments.  Other commands will offer the
marked commit as a default when prompting for their arguments.

@node Reflogs, Commit Buffer, History, Top
@unnumbered Reflogs

You can use @kbd{l h} and @kbd{l H} to browse your @emph{reflog}, the
local history of changes made to your repository heads.  Typing
@kbd{H} will ask for a head, while @kbd{l h} will show the reflog of
@code{HEAD}.

The resulting buffer is just like the buffer produced by @kbd{l l} and
@kbd{l L} that shows the commit history.

@node Commit Buffer, Diffing, Reflogs, Top
@unnumbered Commit Buffer

When you view a commit (perhaps by selecting it in the log buffer,
@ref{History}), the ``commit buffer'' is displayed, showing you
information about the commit and letting you interact with it.

By placing your cursor within the diff or hunk and typing @kbd{a}, you
can apply the same patch to your working copy.  This is useful when
you want to copy a change from another branch, but don't necessarily
want to cherry-pick the whole commit.

By typing @kbd{v} you can apply the patch in reverse, removing all the
lines that were added and adding all the lines that were removed.
This is a convenient way to remove a change after determining that it
introduced a bug.

If the commit message refers to any other commits in the repository by
their unique hash, the hash will be highlighted and you will be able
to visit the referenced commit either by clicking on it or by moving
your cursor onto it and pressing @kbd{RET}.

The commit buffer maintains a history of the commits it has shown.
After visiting a referenced commit you can type @kbd{C-c C-b} to get
back to where you came from.  To go forward in the history, type
@kbd{C-c C-f}.  There are also @code{[back]} and @code{[forward]}
buttons at the bottom of the buffer.

@node Diffing, Tagging, Commit Buffer, Top
@unnumbered Diffing

Egg typically shows diffs in the ``unified'' format.

In any buffer that shows a diff, you can type @kbd{e} anywhere within
the diff to show the two versions of the file in Ediff.  If the diff
is of a file in the status buffer that needs to be merged, you will be
able to use Ediff as an interactive merge tool.  Otherwise, Ediff will
simply show the two versions of the file.

To show the changes from your working tree to another revision, type
@kbd{d}.  To show the changes between two arbitrary revisions, type
@kbd{D}.

You can use @kbd{a} within the diff output to apply the changes to
your working tree.  As usual when point is in a diff header for a
file, all changes for that file are applied, and when it is in a hunk,
only that hunk is.  When the region is active, the applied changes are
restricted to that region.

Typing @kbd{v} will apply the selected changes in reverse.

@node Tagging, Resetting, Diffing, Top
@unnumbered Tagging

Typing @kbd{t t} will make a lighweight tag.  Typing @kbd{t a} will
make an annotated tag.  It will put you in the normal
@code{*magit-log-edit} buffer for writing commit messages, but typing
@kbd{C-c C-c} in it will make the tag instead.  This is controlled by
the @code{Tag} field that will be added to the @code{*magit-log-edit*}
buffer.  You can edit it, if you like.

@node Resetting, Stashing, Tagging, Top
@unnumbered Resetting

Once you have added a commit to your local repository, you can not
change that commit anymore in any way.  But you can reset your current
head to an earlier commit and start over.

If you have published your history already, rewriting it in this way
can be confusing and should be avoided.  However, rewriting your local
history is fine and it is often cleaner to fix mistakes this way than
by reverting commits (with @kbd{v}, for example).

Typing @kbd{x} will ask for a revision and reset your current head to
it.  No changes will be made to your working tree and staging area.
Thus, the @emph{Staged changes} section in the status buffer will show
the changes that you have removed from your commit history.  You can
commit the changes again as if you had just made them, thus rewriting
history.

Typing @kbd{x} while point is in a line that describes a commit will
offer this commit as the default revision to reset to.  Thus, you can
move point to one of the commits in the @emph{Unpushed commits}
section and hit @kbd{x RET} to reset your current head to it.

Type @kbd{X} to reset your working tree and staging area to the most
recently committed state.  This will discard your local modifications,
so be careful.

You can give a prefix to @kbd{x} if you want to reset both the current
head and your working tree to a given commit.  This is the same as
first using an unprefixed @kbd{x} to reset only the head, and then
using @kbd{X}.

@node Stashing, Branching, Resetting, Top
@unnumbered Stashing

You can create a new stash with @kbd{z z}.  Your stashes will be listed
in the status buffer, and you can apply them with @kbd{a} and pop them
with @kbd{A}.  To drop a stash, use @kbd{k}.

With a prefix argument, both @kbd{a} and @kbd{A} will attempt to
reinstate the index as well as the working tree from the stash.

Typing @kbd{z -k z} will create a stash just like @kbd{z z}, but will
leave the changes in your working tree and index. This makes it easier
to, for example, test multiple variations of the same change.

If you just want to make quick snapshots in between edits, you can use
@kbd{z s}, which automatically enters a timestamp as description, and
keeps your working tree and index intact by default.

You can visit and show stashes in the usual way: Typing @kbd{SPC} and
@kbd{DEL} will pop up a buffer with the description of the stash and
scroll it, typing @kbd{RET} will move point into that buffer. Using
@kbd{C-u RET} will move point into that buffer in other window.

@node Branching, The Branch Manager, Stashing, Top
@unnumbered Branching

The current branch is indicated in the header of the status buffer.
You can switch to a different branch by typing @kbd{b b}.  This will
immediately checkout the branch into your working copy, so you
shouldn't have any local modifications when switching branches.

If you try to switch to a remote branch, Egg will offer to create a
local tracking branch for it instead.  This way, you can easily start
working on new branches that have appeared in a remote repository.

Typing @kbd{b b} while point is at a commit description will offer
that commit as the default to switch to.  This will result in a
detached head.


Typing  @kbd{b m} will let you rename a branch. Unless a branch with the same
name already exists, obviously...


To create a new branch and switch to it immediately, type @kbd{b n}.


To delete a branch, type @kbd{b d}. If you're currently on that
branch, Egg will offer to switch to the 'master' branch.

Deleting a branch is only possible if it's already fully merged into
HEAD or its upstream branch. Unless you type @kbd{b D}, that is.
Here be dragons...


Typing @kbd{b v} will list the local and remote branches in a new buffer
called @code{*magit-branches*} from which you can work with them. See
@ref{The Branch Manager} for more details.


@node The Branch Manager, Wazzup, Branching, Top
@unnumbered The Branch Manager

The Branch Manager is a separate buffer called @code{*magit-branches*}
with its own local key map. The buffer contains both local and remote
branches. The current local branch is marked by a ``*'' in front of
the name.

To check out a branch, move your cursor to the desired branch and
press @kbd{RET}.

Typing @kbd{k} will delete the branch in the current line, and
@kbd{C-u k} deletes it even if it hasn't been merged into the current
local branch. Deleting works for both local and remote branches.

By typing @kbd{T} on a local branch, you can change which remote branch it's set to track.

@node Wazzup, Merging, The Branch Manager, Top
@unnumbered Wazzup

Typing @kbd{w} will show a summary of how your other branches relate
to the current branch.

For each branch, you will get a section that lists the commits in that
branch that are not in the current branch.  The sections are initially
collapsed; you need to explicitly open them with @kbd{TAB} (or
similar) to show the lists of commits.

When point is on a @emph{N unmerged commits in ...} title, the
corresponding branch will be offered as the default for a merge.

Hitting @kbd{i} on a branch title will ignore this branch in the
wazzup view.  You can use @kbd{C-u w} to show all branches, including
the ignored ones.  Hitting @kbd{i} on an already ignored branch in
that view will unignore it.

@node Merging, Rebasing, Wazzup, Top
@unnumbered Merging

Egg offers two ways to merge branches: manual and automatic.  A
manual merge will apply all changes to your working tree and staging
area, but will not commit them, while an automatic merge will go ahead
and commit them immediately.

Type @kbd{m m} to initiate merge.

After initiating a merge, the header of the status buffer might remind
you that the next commit will be a merge commit (with more than one
parent).  If you want to abort a manual merge, just do a hard reset to
HEAD with @kbd{X}.

Merges can fail if the two branches you want to merge introduce
conflicting changes.  In that case, the automatic merge stops before the
commit, essentially falling back to a manual merge.  You need to resolve
the conflicts for example with @kbd{e} and stage the resolved files, for
example with @kbd{S}.

You can not stage individual hunks one by one as you resolve them, you
can only stage whole files once all conflicts in them have been
resolved.

@node Rebasing, Rewriting, Merging, Top
@unnumbered Rebasing

Typing @kbd{R} in the status buffer will initiate a rebase or, if one
is already in progress, ask you how to continue.

When a rebase is stopped in the middle because of a conflict, the
header of the status buffer will indicate how far along you are in the
series of commits that are being replayed.  When that happens, you
should resolve the conflicts and stage everything and hit @kbd{R c} to
continue the rebase.  Alternatively, hitting @kbd{c} or @kbd{C} while
in the middle of a rebase will also ask you whether to continue the
rebase.

Of course, you can initiate a rebase in any number of ways, by
configuring @code{git pull} to rebase instead of merge, for example.
Such a rebase can be finished with @kbd{R} as well.

@node Rewriting, Pushing and Pulling, Rebasing, Top
@unnumbered Rewriting

As hinted at earlier, you can rewrite your commit history.  For
example, you can reset the current head to an earlier commit with
@kbd{x}.  This leaves the working tree unchanged, and the status
buffer will show all the changes that have been made since that new
value of the current head.  You can commit these changes again,
possibly splitting them into multiple commits as you go along.

Amending your last commit is a common special case of rewriting
history like this.

Another common way to rewrite history is to reset the head to an
earlier commit, and then to cherry pick the previous commits in a
different order.  You could pick them from the reflog, for example.

Egg has several commands that can simplify the book keeping
associated with rewriting.  These commands all start with the @kbd{r}
prefix key.

Typing @kbd{r b} will start a rewrite operation.  You will be prompted
for a @emph{base} commit.  This commit and all subsequent commits up
until the current head are then put in a list of @emph{Pending
commits}, after which the current head will be reset to the
@emph{parent} of the base commit.  This can be configured to behave
like @code{git rebase}, i.e. exclude the selected base commit from the
rewrite operation, with the @code{magit-rewrite-inclusive} variable.

You would then typically use @kbd{a} and @kbd{A} to cherry pick
commits from the list of pending commits in the desired order, until
all have been applied.  Egg shows which commits have been applied by
changing their marker from @code{*} to @code{.}.

Using @kbd{A} will immediately commit the commit (as usual).  If you
want to combine multiple previous commits into a single new one, use
@kbd{a} to apply them all to your working tree, and then commit them
together.

Egg has no explicit support for rewriting merge commits.  It will
happily include merge commits in the list of pending commits, but
there is no way of replaying them automatically.  You have to redo the
merge explicitly.

You can also use @kbd{v} to revert a commit when you have changed your
mind.  This will change the @code{.} mark back to @code{*}.

Once you are done with the rewrite, type @kbd{r s} to remove the book
keeping information from the status buffer.

If you rather wish to start over, type @kbd{r a}.  This will abort the
rewriting, resetting the current head back to the value it had before
the rewrite was started with @kbd{r s}.

Typing @kbd{r f} will @emph{finish} the rewrite: it will apply all
unused commits one after the other, as if you would us @kbd{A} with
all of them.

You can change the @kbd{*} and @kbd{.} marks of a pending commit
explicitly with @kbd{r *} and @kbd{r .}.

In addition to a list of pending commits, the status buffer will show
the @emph{Pending changes}.  This section shows the diff between the
original head and the current head.  You can use it to review the
changes that you still need to rewrite, and you can apply hunks from
it, like from any other diff.

@node Pushing and Pulling, Submodules, Rewriting, Top
@unnumbered Pushing and Pulling

Egg will run @code{git push} when you type @kbd{P P}.  If you give
a prefix argument to @kbd{P P}, you will be prompted for the repository
to push to.  When no default remote repository has been configured yet
for the current branch, you will be prompted as well.  Typing @kbd{P P}
will only push the current branch to the remote.  In other words, it
will run @code{git push <remote> <branch>}.  The branch will be created
in the remote if it doesn't exist already.  The local branch will be
configured so that it pulls from the new remote branch. If you give
a double prefix argument to @kbd{P P}, you will be prompted in addition
for the target branch to push to.  In other words, it will run @code{git
push <remote> <branch>:<target>}.

Typing @kbd{f f} will run @code{git fetch}.  It will prompt for the name
of the remote to update if there is no default one.  Typing @kbd{f o}
will always prompt for the remote.  Typing @kbd{F F} will run @code{git
pull}.  When you don't have a default branch configured to be pulled
into the current one, you will be asked for it.

If there is a default remote repository for the current branch, Egg
will show that repository in the status buffer header.

In this case, the status buffer will also have a @emph{Unpushed
commits} section that shows the commits on your current head that are
not in the branch named @code{<remote>/<branch>}.  This section works
just like the history buffer: you can see details about a commit with
@kbd{RET}, compare two of them with @kbd{.} and @kbd{=}, and you can
reset your current head to one of them with @kbd{x}, for example. If
you want to push the changes then type @kbd{P P}.

When the remote branch has changes that are not in the current branch,
Egg shows them in a section called @emph{Unpulled changes}.  Typing
@kbd{F F} will fetch and merge them into the current branch.

@node Submodules, Bisecting, Pushing and Pulling, Top
@unnumbered Submodules

@table @kbd
@item M u
Update the submodules, with a prefix argument it will initializing.

@item M i
Initialize the submodules.

@item M b
Update and initialize the submodules in one go.

@item M s
Synchronizes submodules' remote URL configuration setting to the value
specified in .gitmodules.
@end table


@node Bisecting, Using Egg Extensions, Submodules, Top
@unnumbered Bisecting

Egg supports bisecting by showing how many revisions and steps are
left to be tested in the status buffer. You can control the bisect
session from both the status and from log buffers with the @kbd{B} key
menu.

Typing @kbd{B s} will start a bisect session.  You will be prompted
for a revision that is known to be bad (defaults to @emph{HEAD}) and
for a revision that is known to be good (defaults to the revision at
point if there is one). git will select a revision for you to test,
and Egg will update its status buffer accordingly.

You can tell git that the current revision is good with @kbd{B g},
that it is bad with @kbd{B b} or that git should skip it with @kbd{B
k}. You can also tell git to go into full automatic mode by giving it
the name of a script to run for each revision to test with @kbd{B u}.

The current status can be shown as a log with @kbd{B l}. It contains
the revisions that have already been tested and your decisions about
their state.

The revisions left to test can be visualized in gitk with @kbd{B v}.

When you're finished bisecting you have to reset the session with
@kbd{B r}.


@node Using Egg Extensions, Using Git Directly, Bisecting, Top
@unnumbered Egg Extensions

@menu
* Activating extensions::       
* Interfacing with Subversion::  
* Interfacing with Topgit::     
* Interfacing with StGit::      
* Developing Extensions::       
@end menu

@node Activating extensions, Interfacing with Subversion, Using Egg Extensions, Using Egg Extensions
@section Activating extensions

Egg comes with a couple of shipped extensions that allow interaction
with @code{git-svn}, @code{topgit} and @code{stgit}. See following
sections for specific details on how to use them.

Extensions can be activated globally or on a per-repository basis. Since
those extensions are implemented as minor modes, one can use for example
@kbd{M-x magit-topgit-mode} to toggle the @code{topgit} extension,
making the corresponding section and commands (un)available.

In order to do that automatically (and for every repository), one can
use for example:

@example
(add-hook 'magit-mode-hook 'turn-on-magit-topgit)
@end example

Egg also allows configuring different extensions, based on the git
repository configuration.

@example
(add-hook 'magit-mode-hook 'magit-load-config-extensions)
@end example

This will read git configuration variables and activate the
relevant extensions.

For example, after running the following commands, the @code{topgit}
extension will be loaded for every repository, while the @code{svn} one
will be loaded only for the current one.

@example
$ git config --global --add magit.extension topgit
$ git config --add magit.extension svn
@end example

Note the @code{--add} flag, which means that each extension gets its own
line in the @code{config} file.

@node Interfacing with Subversion, Interfacing with Topgit, Activating extensions, Using Egg Extensions
@section Interfacing with Subversion

Typing @kbd{N r} runs @code{git svn rebase}, typing @kbd{N c} runs
@code{git svn dcommit} and typing @kbd{N f} runs @code{git svn fetch}.

@kbd{N s} will prompt you for a (numeric, Subversion) revision and
then search for a corresponding Git sha1 for the commit. This is
limited to the path of the remote Subversion repository. With a prefix
(@kbd{C-u N s} the user will also be prompted for a branch to search
in.

@node Interfacing with Topgit, Interfacing with StGit, Interfacing with Subversion, Using Egg Extensions
@section Interfacing with Topgit

Topgit (http://repo.or.cz/r/topgit.git) is a patch queue manager that
aims at being close as possible to raw Git, which makes it easy to use
with Egg. In particular, it does not require to use a different set of
commands for ``commit'', ``update'',… operations.

@file{magit-topgit.el} provides basic integration with Egg, mostly by
providing a ``Topics'' section.

Topgit branches can be created the regular way, by using a ``t/'' prefix
by convention. So, creating a ``t/foo'' branch will actually populate
the ``Topics'' section with one more branch after committing
@file{.topdeps} and @file{.topmsg}.

Also, the way we pull (see @ref{Pushing and Pulling}) such a branch is
slightly different, since it requires updating the various dependencies
of that branch. This should be mostly transparent, except in case
of conflicts.

@node Interfacing with StGit, Developing Extensions, Interfacing with Topgit, Using Egg Extensions
@section Interfacing with StGit

StGit (http://www.procode.org/stgit) is a Python application providing
similar functionality to Quilt (i.e. pushing/popping patches to/from a
stack) on top of Git. These operations are performed using Git commands
and the patches are stored as Git commit objects, allowing easy merging
of the StGit patches into other repositories using standard Git
functionality.

@file{magit-stgit.el} provides basic integration with Egg, mostly by
providing a ``Series'' section, whose patches can be seen as regular
commits through the ``visit'' action.

You can change the current patch in a series with the ``apply'' action,
as well as you can delete them using the ``discard'' action.

Additionally, the @code{magit-stgit-refresh} and
@code{magit-stgit-rebase} commands let you perform the respective StGit
operations.

@node Developing Extensions,  , Interfacing with StGit, Using Egg Extensions
@section Developing Extensions

Egg provides a generic mechanism to allow cooperation with Git-related
systems, such as foreign VCS, patch systems,…

In particular it allows to:

@itemize @bullet
@item
Define sections to display specific informations about the current state
of the repository, and place them relatively to existing sections.

@code{magit-define-inserter} automagically defines two hooks called
@code{magit-before-insert-SECTION-hook} and
@code{magit-after-insert-SECTION-hook} that allow to generate and place
more sections.

In the following example, we use the builtin ``stashes'' section to
place our own ``foo'' one.

@example
(magit-define-inserter foo ()
  (magit-git-section 'foo
                     "Foo:" 'foo-wash-function
                     "foo" "arg1" "arg2"))
(add-hook 'magit-after-insert-stashes-hook 'magit-insert-foo)
@end example

@item
Define new types of objects in those sections.

The function @code{foo-wash-function} defined above post-processes each
line of the output of the ``git foo arg1 arg2'' command, and is able to
associate a type to certain lines.

A simple implementation could be:

@example
(defun foo-wash-function ()
  (let ((foo (buffer-substring (line-beginning-position) (line-end-position))))
    (goto-char (line-beginning-position))
    (magit-with-section foo 'foo
      (magit-set-section-info foo)
      (forward-line))))
@end example

In this case, every line of the command output is transformed into an
object of type @code{'foo}.

@item
Alter behavior of generic commands to dispatch them correctly to the
relevant system, optionally making use of the newly defined types.

@example
(magit-add-action (item info "discard")
  ((foo)
   (do-something-meaningful-for-discarding-a-foo)))
@end example

This will alter the behavior of @kbd{k}, when applied to those objects.

@item
Plug a different logic into basic commands, to reflect the presence of
the extension.

@code{magit-define-command} automagically defines
a @code{magit-CMD-command-hook} that can contain a list of functions to
call before the actual core code. Execution stops after the first hook
that returns a non-nil value. This leaves room for extension logic.

@example
(add-hook 'magit-create-branch-command-hook 'foo-create-branch)
@end example

The function @code{foo-create-branch} will be called each time an
attempt is made to create a branch, and can, for example, react to
a certain name convention.

@item
Define new commands and associated menu.

This part is not really specific to extensions, except that menus take
place in the ``Extensions'' submenu.

@end itemize

It is suggested that Egg extensions authors stick to the convention of
making extensions minor modes. This has many advantages, including the
fact that users are able to toggle extensions, and that it's easy to
configure a specific set of extensions for a given repository.

Shipped extensions can serve as an example of how to develop
new extensions.

Basically a @code{foo} extension should provide a @code{magit-foo-mode}
minor mode, as well as a @code{turn-on-magit-foo} function.  The main
task of the minor mode is to register/unregister the various hooks that
the extension requires. The registered actions on the other hand can be
left alone and activated globally, since they can be run only on
displayed items, which won't happen when the minor mode is off.

Don't forget to call @code{magit-refresh} when the minor mode is toggled
interactively, so that the relevant sections can be shown or hidden.

@node Using Git Directly, Customization, Using Egg Extensions, Top
@unnumbered Using Git Directly

For situations when Egg doesn't do everything you need, you can run
raw Git commands using @kbd{:}.  This will prompt for a Git command, run
it, and refresh the status buffer.  The output can be viewed by typing
@kbd{$}.


@node Customization, Frequently Asked Questions, Using Git Directly, Top
@unnumbered Customization

The following variables can be used to adapt Egg to your workflow:

@table @code

@item magit-git-executable
The name of the Git executable.

@item magit-git-standard-options
Standard options when running Git.

@item magit-repo-dirs
Directories containing Git repositories.

Egg will look into these directories for Git repositories and offer
them as choices for @code{magit-status}.

@item magit-repo-dirs-depth
The maximum depth to look for Git repos.

When looking for a Git repository below the directories in
@code{magit-repo-dirs}, Egg will only descend this many levels deep.

@item magit-save-some-buffers
Non-nil means that @code{magit-status} will save modified buffers
before running.  Setting this to @code{t} will ask which buffers to
save, setting it to @code{'dontask} will save all modified buffers
without asking.

@item magit-save-some-buffers-predicate
Specifies a predicate function on @code{magit-save-some-buffers} to
determine which unsaved buffers should be prompted for saving.

@item magit-commit-all-when-nothing-staged
Determines what @code{magit-log-edit} does when nothing is staged.
Setting this to @code{nil} will make it do nothing, setting it to
@code{t} will arrange things so that the actual commit command will
use the @code{--all} option, setting it to @code{'ask} will first ask
for confirmation whether to do this, and setting it to
@code{'ask-stage} will cause all changes to be staged, after a
confirmation.

@item magit-commit-signoff
When performing @code{git commit} adds @code{--signoff}.

@item magit-log-cutoff-length
The maximum number of commits to show in the @code{log} and
@code{whazzup} buffers.

@item magit-log-infinite-length
Number of log used to show as maximum for
@code{magit-log-cutoff-length}.

@item magit-log-auto-more
Insert more log entries automatically when moving past the last entry.

Only considered when moving past the last entry with @code{magit-goto-next-section}.

@item magit-process-popup-time
Popup the process buffer if a command takes longer than this many
seconds.

@item magit-revert-item-confirm
Require acknowledgment before reverting an item.

@item magit-log-edit-confirm-cancellation
Require acknowledgment before canceling the log edit buffer.

@item magit-remote-ref-format
What format to use for autocompleting refs, in pariticular for
remotes.

Autocompletion is used by functions like @code{magit-checkout},
@code{magit-interactive-rebase} and others which offer branch name
completion.

The value @code{'name-then-remote} means remotes will be of the form
@code{name (remote)}, while the value @code{'remote-slash-name} means
that they'll be of the form @code{remote/name}. I.e. something that's
listed as @code{remotes/upstream/next} by @code{git branch -l -a} will
be @code{upstream/next}.

@item magit-process-connection-type
Connection type used for the git process.

@code{nil} mean pipe, it is usually faster and more efficient, and
work on cygwin.  @code{t} mean pty, it enable magit to prompt for
passphrase when needed.

@item magit-completing-read-function
Function to be called when requesting input from the user.

@item magit-create-branch-behaviour
Where magit will create a new branch if not supplied a branchname or
ref.

The value @code{'at-head} means a new branch will be created at the
tip of your current branch, while the value @code{'at-point} means
magit will try to find a valid reference at point...

@item magit-status-buffer-switch-function
Function for @code{magit-status} to use for switching to the status
buffer.

The function is given one argument, the status buffer.

@item magit-rewrite-inclusive
Whether magit includes the selected base commit in a rewrite
operation.

@code{t} means both the selected commit as well as any subsequent
commits will be rewritten. This is magit's default behaviour,
equivalent to @code{git rebase -i $@{REV~1@}}

@verbatim
  A'---B'---C'---D'
  ^
@end verbatim

@code{nil} means the selected commit will be literally used as
@code{base}, so only subsequent commits will be rewritten. This is
consistent with git-rebase, equivalent to @code{git rebase -i
$@{REV@}}, yet more cumbersome to use from the status buffer.

@verbatim
  A---B'---C'---D'
  ^
@end verbatim

@item magit-topgit-executable
The name of the TopGit executable.

@item magit-topgit-branch-prefix
Convention prefix for topic branch creation.

@end table

@node Frequently Asked Questions,  , Customization, Top
@unnumbered Frequently Asked Questions

@menu
* FAQ - Changes::               
* FAQ 1 - Troubleshooting::     
* FAQ 2 - Display issues::      
@end menu

@node FAQ - Changes, FAQ 1 - Troubleshooting, Frequently Asked Questions, Frequently Asked Questions
@section Changes

@itemize @bullet

@item
v1.1: Changed the way extensions work. Previously, they were enabled
unconditionally once the library was loaded. Now they are minor modes
that need to be activated explicitly (potentially on a per-repository
basis). See @ref{Activating extensions}.

@end itemize

@node FAQ 1 - Troubleshooting, FAQ 2 - Display issues, FAQ - Changes, Frequently Asked Questions
@section Troubleshooting

@menu
* FAQ 1-1::                     How do I get raw error messages from git?
@end menu

@node FAQ 1-1,  , FAQ 1 - Troubleshooting, FAQ 1 - Troubleshooting
@subsection Question 1.1

How do I get raw error messages from git?

@subsubheading Answer

If a command goes wrong, you can hit @kbd{$} to access the git process
buffer. There, the entire trace for the latest operation is available.

@node FAQ 2 - Display issues,  , FAQ 1 - Troubleshooting, Frequently Asked Questions
@section Display issues

@menu
* FAQ 2-1::                     How do I fix international characters display?
@end menu

@node FAQ 2-1,  , FAQ 2 - Display issues, FAQ 2 - Display issues
@subsection Question 2.1

How do I fix international characters display?

@subsubheading Answer

Please make sure your Egg buffer uses a compatible coding system.
In the particular case of file names, git itself quotes them by
default. You can disable this with one of the following approaches:

@example
$ git config core.quotepath false
@end example

or

@example
(setq magit-git-standard-options (append magit-git-standard-options
                                         '("-c" "core.quotepath=false")))
@end example

The latter might not work in old versions of git.

@bye
